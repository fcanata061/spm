#!/bin/sh
# spm - Simple POSIX Package Manager (Parte 1/6)
# Configuração, variáveis globais e funções utilitárias

###############################################################################
# Carrega configuração
###############################################################################
[ -f /etc/spm/config ] && . /etc/spm/config
[ -f "$HOME/.spm/config" ] && . "$HOME/.spm/config"

###############################################################################
# Variáveis principais (fallbacks)
###############################################################################
: "${SPM_ROOT:=/var/spm}"
: "${SPM_PREFIX:=/usr}"
: "${SPM_SRC_CACHE:=$SPM_ROOT/sources}"
: "${SPM_BUILD_DIR:=$SPM_ROOT/build}"
: "${SPM_LOG_DIR:=$SPM_ROOT/logs}"
: "${SPM_DB_DIR:=$SPM_ROOT/db}"
: "${SPM_PKG_DIR:=$SPM_ROOT/pkgs}"
: "${SPM_BACKUP_DIR:=$SPM_ROOT/backups}"

# Toolchain
: "${SPM_TOOLCHAIN_ROOT:=/tools}"
: "${SPM_TOOLCHAIN_BUILD:=$SPM_ROOT/toolchain}"
: "${SPM_TOOLCHAIN_LOGS:=$SPM_ROOT/toolchain/logs}"

# Hooks
: "${SPM_HOOKS_GLOBAL:=/etc/spm/hooks}"
: "${SPM_HOOKS_USER:=$HOME/.spm/hooks}"
: "${SPM_HOOKS_PKG:=./hooks}"

# Build
: "${SPM_JOBS:=1}"
: "${SPM_CFLAGS:=-O2 -pipe}"
: "${SPM_CXXFLAGS:=$SPM_CFLAGS}"
: "${SPM_LDFLAGS:=}"
: "${SPM_USE_CCACHE:=no}"
: "${SPM_STRIP_DEFAULT:=no}"

# UI / Logs
: "${SPM_COLOR:=yes}"
: "${SPM_SPINNER:=yes}"
: "${SPM_LOG_LEVEL:=info}"

# Segurança / SHA256
: "${SPM_VERIFY_SHA256:=yes}"
: "${SPM_AUTO_SHA256:=no}"

###############################################################################
# Flags globais (inicialização)
###############################################################################
SPM_FORCE_STRIP="no"
SPM_FAKEROOT="no"
SPM_FORCE_REBUILD="no"
SPM_DRY_RUN="no"
SPM_KEEP_SRC="no"
SPM_YES="no"
SPM_PREFIX_FINAL="$SPM_PREFIX"
SPM_DESTDIR=""

###############################################################################
# Funções utilitárias
###############################################################################
log() {
    local level="$1"
    shift
    case "$level" in
        error) [ "$SPM_COLOR" = "yes" ] && printf "\033[31m[ERROR]\033[0m %s\n" "$*" || printf "[ERROR] %s\n" "$*" ;;
        warn)  [ "$SPM_COLOR" = "yes" ] && printf "\033[33m[WARN]\033[0m %s\n" "$*" || printf "[WARN] %s\n" "$*" ;;
        info)  [ "$SPM_LOG_LEVEL" != "error" ] && { [ "$SPM_COLOR" = "yes" ] && printf "\033[32m[INFO]\033[0m %s\n" "$*" || printf "[INFO] %s\n" "$*"; } ;;
        debug) [ "$SPM_LOG_LEVEL" = "debug" ] && { [ "$SPM_COLOR" = "yes" ] && printf "\033[36m[DEBUG]\033[0m %s\n" "$*" || printf "[DEBUG] %s\n" "$*"; } ;;
        *) printf "[LOG] %s\n" "$*" ;;
    esac
}

spinner_start() {
    [ "$SPM_SPINNER" = "yes" ] || return
    # Placeholder spinner start
}

spinner_stop() {
    [ "$SPM_SPINNER" = "yes" ] || return
    # Placeholder spinner stop
}

mkdirp() { mkdir -p "$@" || { log error "Falha ao criar diretório $*"; exit 1; } }

safe_mv() {
    local src="$1"
    local dst="$2"
    mv "$src" "$dst" || { log error "Falha ao mover $src → $dst"; return 1; }
}

safe_rsync() {
    local src="$1"
    local dst="$2"
    rsync -a --remove-source-files "$src/" "$dst/" || { log error "Falha ao rsync $src → $dst"; return 1; }
}

timestamp() { date +"%Y-%m-%dT%H:%M:%S"; }

uuid() { cat /proc/sys/kernel/random/uuid 2>/dev/null || head -c8 /dev/urandom | xxd -p; }
# Download, Git, SHA256 e Extract
###############################################################################
# Função: baixar arquivo (curl/wget) com cache e validação
###############################################################################
spm_fetch() {
    local url="$1"
    local dest="$SPM_SRC_CACHE/$(basename "$url")"
    mkdirp "$SPM_SRC_CACHE"

    if [ -f "$dest" ]; then
        log info "Arquivo já existe no cache: $dest"
    else
        if command -v curl >/dev/null 2>&1; then
            log info "Baixando $url via curl..."
            curl -L -o "$dest" "$url" || { log error "Falha no download $url"; return 1; }
        elif command -v wget >/dev/null 2>&1; then
            log info "Baixando $url via wget..."
            wget -O "$dest" "$url" || { log error "Falha no download $url"; return 1; }
        else
            log error "curl ou wget não encontrados"
            return 1
        fi
    fi
    echo "$dest"
}

###############################################################################
# Função: clonar ou atualizar repositório Git
###############################################################################
spm_git_clone() {
    local repo="$1"
    local dest="$2"
    local branch="${3:-main}"
    mkdirp "$dest"

    if [ -d "$dest/.git" ]; then
        log info "Repositório já existe em $dest, fazendo pull..."
        git -C "$dest" pull || { log error "Falha no git pull em $dest"; return 1; }
    else
        log info "Clonando repositório $repo..."
        git clone --branch "$branch" "$repo" "$dest" || { log error "Falha no git clone $repo"; return 1; }
    fi
}

###############################################################################
# Função: criar SHA256
###############################################################################
spm_create_sha256() {
    local file="$1"
    [ -z "$file" ] && { log error "Arquivo não informado"; return 1; }
    log info "Criando SHA256 para $file..."
    sha256sum "$file" > "$file.sha256"
    log info "SHA256 criado em $file.sha256"
}

###############################################################################
# Função: verificar SHA256
###############################################################################
spm_verify_sha256() {
    local file="$1"
    local expected="$2"

    [ "$SPM_VERIFY_SHA256" = "no" ] && return 0

    if [ -z "$expected" ]; then
        if [ "$SPM_AUTO_SHA256" = "yes" ]; then
            spm_create_sha256 "$file"
            return 0
        fi
        log warn "SHA256 não fornecido para $file, pulando verificação"
        return 0
    fi

    log info "Verificando SHA256 de $file..."
    local sum
    sum=$(sha256sum "$file" | awk '{print $1}')
    if [ "$sum" != "$expected" ]; then
        if [ "$SPM_FORCE" = "yes" ]; then
            log warn "SHA256 mismatch, mas continuando por --force: $file"
        else
            log error "SHA256 mismatch: esperado $expected, obtido $sum"
            return 1
        fi
    else
        log info "SHA256 verificado com sucesso: $file"
    fi
}

###############################################################################
# Função: extrair arquivos (tar, zip, etc.) para dest
###############################################################################
spm_extract() {
    local file="$1"
    local dest="$2"
    mkdirp "$dest"

    case "$file" in
        *.tar.gz|*.tgz) tar xzf "$file" -C "$dest" ;;
        *.tar.bz2|*.tbz2) tar xjf "$file" -C "$dest" ;;
        *.tar.xz|*.txz) tar xJf "$file" -C "$dest" ;;
        *.zip) unzip -q "$file" -d "$dest" ;;
        *) log error "Formato de arquivo não suportado: $file"; return 1 ;;
    esac

    log info "Extraído $file para $dest"
}
# Build, Patch, Compile, Install, Strip, Hooks, fakeroot
###############################################################################
# Função: executar hooks
###############################################################################
run_hooks() {
    local phase="$1"
    for dir in "$SPM_HOOKS_GLOBAL" "$SPM_HOOKS_USER" "$SPM_HOOKS_PKG"; do
        [ -d "$dir/$phase.d" ] || continue
        for hook in "$dir/$phase.d/"*.sh; do
            [ -x "$hook" ] && "$hook" "$spm_name" "$spm_version"
        done
    done
}

###############################################################################
# Função: aplicar patches
###############################################################################
spm_patch() {
    local patches="$1"
    local workdir="$2"
    [ -z "$patches" ] && return 0

    for p in $patches; do
        log info "Aplicando patch $p..."
        patch -d "$workdir" -p1 < "$p" || {
            [ "$SPM_FORCE" = "yes" ] && log warn "Patch falhou, mas continuando por --force: $p" || return 1
        }
    done
}

###############################################################################
# Função: build do pacote (não instala)
###############################################################################
spm_build() {
    local workdir="$SPM_BUILD_DIR/$spm_name-$spm_version"
    mkdirp "$SPM_BUILD_DIR"
    mkdirp "$workdir"

    # Se já buildado e não for rebuild, pular
    [ -f "$SPM_DB_DIR/$spm_name-$spm_version.built" ] && [ "$SPM_FORCE_REBUILD" != "yes" ] && {
        log info "$spm_name-$spm_version já buildado, pulando"
        return 0
    }

    run_hooks pre-build

    # Aplicar patch
    spm_patch "$spm_patches" "$workdir" || return 1

    # Configuração
    if [ -n "$spm_configure" ]; then
        log info "Configurando $spm_name..."
        (cd "$workdir" && eval "$spm_configure") || return 1
    fi

    # Compilação
    if [ -n "$spm_make" ]; then
        log info "Compilando $spm_name..."
        (cd "$workdir" && eval "$spm_make -j$SPM_JOBS") || return 1
    fi

    # Marca como built
    echo "$(timestamp)" > "$SPM_DB_DIR/$spm_name-$spm_version.built"
    run_hooks post-build
    log info "Build concluído: $spm_name-$spm_version"
}

###############################################################################
# Função: instalar pacote
###############################################################################
spm_install() {
    local dest="${SPM_DESTDIR:-$SPM_PREFIX_FINAL}"
    local use_fakeroot="$SPM_FAKEROOT"

    # Build se necessário
    [ ! -d "$SPM_BUILD_DIR/$spm_name-$spm_version" ] && spm_build || true

    run_hooks pre-install
    log info "Instalando $spm_name-$spm_version em $dest..."

    if [ "$use_fakeroot" = "yes" ] && command -v fakeroot >/dev/null 2>&1; then
        fakeroot sh -c "cd $SPM_BUILD_DIR/$spm_name-$spm_version && eval \"$spm_make_install\""
    else
        (cd "$SPM_BUILD_DIR/$spm_name-$spm_version" && eval "$spm_make_install") || return 1
    fi

    # Strip se necessário
    local strip_pkg="$spm_strip"
    [ "$SPM_FORCE_STRIP" = "yes" ] && strip_pkg="yes"
    if [ "$strip_pkg" = "yes" ]; then
        log info "Stripando binários..."
        find "$dest" -type f -exec file {} \; | grep 'ELF' | cut -d: -f1 | while read bin; do
            strip --strip-unneeded "$bin" 2>/dev/null || true
        done
    fi

    run_hooks post-install

    # Atualiza manifest completo
    mkdirp "$SPM_DB_DIR"
    local manifest="$SPM_DB_DIR/$spm_name-$spm_version.manifest"
    mkdirp "$(dirname "$SPM_DB_DIR")/files"
    local files_list="$SPM_DB_DIR/files/$spm_name-$spm_version.files"

    find "$dest" -type f > "$files_list"
    cat > "$manifest" <<EOF
spm_name=$spm_name
spm_version=$spm_version
spm_installed_by=${SPM_INSTALLED_BY:-manual}
spm_built_at=$(timestamp)
spm_built_path=$SPM_BUILD_DIR/$spm_name-$spm_version
spm_files_list=$files_list
spm_protected=${spm_protected:-no}
EOF

    log info "Instalação concluída: $spm_name-$spm_version"
}
# Dependências, órfãos, autoremove, search, info, upgrade
###############################################################################
# Função: topo-sort de dependências (build-order)
###############################################################################
spm_resolve_deps() {
    local pkg="$1"
    local resolved="$2"
    local dep
    [ -z "$resolved" ] && resolved=""

    for dep in $(eval echo "\$spm_build_deps" "\$spm_deps"); do
        case " $resolved " in
            *" $dep "*) continue ;;
        esac
        spm_resolve_deps "$dep" "$resolved"
        resolved="$resolved $dep"
    done

    echo "$resolved $pkg"
}

###############################################################################
# Função: listar pacotes órfãos
###############################################################################
spm_orphans() {
    mkdirp "$SPM_DB_DIR"
    local pkg deps installed auto_orphans
    installed=$(ls "$SPM_DB_DIR" | sed 's/\.manifest$//')
    auto_orphans=""
    for pkg in $installed; do
        grep -q 'manual' "$SPM_DB_DIR/$pkg.manifest" && continue
        deps=$(grep -h "spm_deps=" "$SPM_PKG_DIR/$pkg.spm" 2>/dev/null | cut -d= -f2 | tr -d '"')
        if [ -z "$deps" ]; then
            auto_orphans="$auto_orphans $pkg"
        fi
    done
    echo "$auto_orphans"
}

###############################################################################
# Função: remover pacote
###############################################################################
spm_remove() {
    local pkg="$1"
    local manifest="$SPM_DB_DIR/$pkg.manifest"
    [ ! -f "$manifest" ] && { log warn "Pacote $pkg não está instalado"; return 1; }

    run_hooks pre-remove
    log info "Removendo $pkg..."

    # Backup
    mkdirp "$SPM_BACKUP_DIR"
    tar -cf "$SPM_BACKUP_DIR/${pkg}-$(timestamp).tar" -C "$SPM_PREFIX" "$(cat $manifest | grep spm_files_list | cut -d= -f2 | xargs -I{} dirname {})"

    xargs rm -rf < "$(grep spm_files_list "$manifest" | cut -d= -f2)" 2>/dev/null || true
    rm -f "$manifest"

    run_hooks post-remove
    log info "$pkg removido"
}

###############################################################################
# Função: autoremove pacotes órfãos
###############################################################################
spm_autoremove() {
    local dry_run="$1"
    local orphans
    orphans=$(spm_orphans)
    [ -z "$orphans" ] && { log info "Nenhum pacote órfão"; return; }

    if [ "$dry_run" = "yes" ]; then
        log info "Pacotes órfãos que seriam removidos: $orphans"
    else
        for pkg in $orphans; do
            spm_remove "$pkg"
        done
    fi
}
###############################################################################
# Função: sincronizar DB com repo Git
###############################################################################
spm_sync() {
    local repo_dir="$SPM_DB_DIR"
    [ ! -d "$repo_dir/.git" ] && { log warn "Repo Git não inicializado em $repo_dir"; return 1; }

    log info "Sincronizando DB com repo Git em $repo_dir..."
    cd "$repo_dir" || return 1

    git add . 
    git commit -m "Atualização automática do SPM DB em $(date '+%Y-%m-%d %H:%M:%S')" 2>/dev/null || true
    git push || { log error "Falha ao dar push para o repo Git"; return 1; }

    log info "Sincronização concluída"
}
###############################################################################
# Função: search pacote
###############################################################################
spm_search() {
    local query="$1"
    grep -i "$query" "$SPM_PKG_DIR"/*.spm | sed 's#.*/##;s/\.spm$//'
}

###############################################################################
# Função: info pacote
###############################################################################
spm_info() {
    local pkg="$1"
    local manifest="$SPM_DB_DIR/$pkg.manifest"
    local recipe="$SPM_PKG_DIR/$pkg.spm"

    echo "Informações do pacote: $pkg"
    [ -f "$recipe" ] && grep '^spm_' "$recipe"
    if [ -f "$manifest" ]; then
        echo "Instalado em: $(cat "$manifest" | grep spm_built_path | cut -d= -f2)"
        grep 'manual\|auto' "$manifest"
    else
        echo "Pacote não instalado"
    fi
}

###############################################################################
# Função: upgrade pacote (major-only, opcional --force)
###############################################################################
spm_upgrade() {
    local pkg="$1"
    local manifest="$SPM_DB_DIR/$pkg.manifest"
    [ ! -f "$manifest" ] && { log info "$pkg não instalado, instalando..."; spm_install "$pkg"; return; }

    local current_version new_version
    current_version=$(basename "$manifest" | sed 's/^.*-//;s/\.manifest$//')
    new_version=$(ls "$SPM_PKG_DIR/$pkg-"*.spm 2>/dev/null | sed 's#.*/##;s/\.spm$//' | sort -V | tail -n1)

    if [ -z "$new_version" ] || [ "$new_version" = "$current_version" ]; then
        log info "$pkg já está na versão mais recente ($current_version)"
    else
        log info "Atualizando $pkg: $current_version → $new_version"
        spm_install "$pkg"
    fi
}
###############################################################################
# Função: construir toolchain LFS
###############################################################################
spm_toolchain() {
    local phase="$1"

    case "$phase" in
        prepare)
            log info "Preparando diretórios da toolchain..."
            mkdirp "$SPM_TOOLCHAIN_ROOT" "$SPM_TOOLCHAIN_BUILD" "$SPM_TOOLCHAIN_LOGS"
            export PATH="$SPM_TOOLCHAIN_ROOT/bin:$PATH"
            ;;
        binutils-pass1|gcc-pass1|headers|glibc|binutils-pass2|gcc-pass2)
            local recipe="$SPM_PKG_DIR/$phase.spm"
            [ ! -f "$recipe" ] && { log error "Receita não encontrada: $recipe"; return 1; }
            log info "Executando fase $phase da toolchain..."
            . "$recipe"
            spm_build
            spm_install
            ;;
        finalize)
            log info "Finalizando toolchain..."
            # Ajustes finais de PATH, symlinks e permissões
            ;;
        build)
            spm_toolchain prepare
            for f in binutils-pass1 gcc-pass1 headers glibc binutils-pass2 gcc-pass2 finalize; do
                spm_toolchain "$f"
            done
            ;;
        *)
            log error "Fase de toolchain inválida: $phase"
            return 1
            ;;
    esac
}
# spm - Parte 6/6: CLI principal e integração final

###############################################################################
# Função: mostrar ajuda
###############################################################################
usage() {
    cat <<EOF
SPM - Simple POSIX Package Manager

Uso: spm <comando> [pacote/categoria] [opções]

Comandos:
  build <pkg>          Compila pacote sem instalar
  install <pkg>        Instala pacote (suporta --strip, --fakeroot)
  remove <pkg>         Remove pacote
  upgrade <pkg>        Atualiza pacote para versão maior
  search <query>       Busca pacotes no repo
  info <pkg>           Mostra informações do pacote
  orphans              Lista pacotes órfãos
  autoremove [--dry-run] Remove pacotes órfãos
  toolchain <fase>     Constrói toolchain LFS (prepare, binutils-pass1, gcc-pass1, headers, glibc, binutils-pass2, gcc-pass2, finalize, build)
  --rebuild [-jN] [--force]  Recompila todo o sistema
  -s <categoria>       Recompila categoria específica de pacotes
  sha256 create <file> Cria SHA256
  sha256 verify <file> Verifica SHA256

Opções globais:
  --strip           Força strip de binários
  --fakeroot        Usa fakeroot na instalação
  -h, --help        Mostra esta ajuda
EOF
}

###############################################################################
# Flags globais default
###############################################################################
SPM_FORCE_STRIP="no"
SPM_FAKEROOT="no"
SPM_JOBS="$SPM_JOBS"
SPM_FORCE_REBUILD="no"
SP_FORCE="no"
SPM_INSTALLED_BY="manual"

###############################################################################
# Parsing de argumentos
###############################################################################
cmd="$1"
arg1="$2"
shift 2 || true

for arg in "$@"; do
    case "$arg" in
        --strip) SPM_FORCE_STRIP="yes" ;;
        --fakeroot) SPM_FAKEROOT="yes" ;;
        --force) SP_FORCE="yes"; SPM_FORCE_REBUILD="yes" ;;
        -j*) SPM_JOBS="${arg#-j}" ;;
        -h|--help) usage; exit 0 ;;
    esac
done

###############################################################################
# CLI principal: dispatch
###############################################################################
case "$cmd" in
    -b) spm_build "$arg1" ;;
    -i) spm_install "$arg1" ;;
    -s)
        [ -z "$arg1" ] && { log error "Categoria não informada"; exit 1; }
        spm_rebuild_category "$arg1" ;;
    build) spm_build "$arg1" ;;
    install) spm_install "$arg1" ;;
    remove) spm_remove "$arg1" ;;
    upgrade) spm_upgrade "$arg1" ;;
    search) spm_search "$arg1" ;;
    info) spm_info "$arg1" ;;
    orphans) spm_orphans ;;
    autoremove) spm_autoremove "$( [ "$arg1" = "--dry-run" ] && echo yes || echo no )" ;;
    toolchain) spm_toolchain "$arg1" ;;
    sync) spm_sync ;;
    --rebuild)
        log info "Recompilando todo o sistema..."
        spm_recompile_all "$@" ;;
    sha256)
        case "$arg1" in
            create) spm_create_sha256 "$2" ;;
            verify) spm_verify_sha256 "$2" "$3" ;;
            *) log error "Subcomando SHA256 inválido"; exit 1 ;;
        esac
        ;;
    *) usage ;;
esac
